<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<script src="steps.js"></script>
	<link rel="stylesheet" type="text/css" href="style.css">
	<title>Replayer</title>
</head>
<body>
	<div id="screen" style="background-color: black; color: white; min-height: 80vh;"></div>
	<div id="buttons" style="text-align: center;">
		<span id="current-step">(Kein Replay</span><span id="nb-steps"> geladen)</span>
		<button onclick="pre();">&#x25c0;</button>
		<button onclick="playPause(this);">&#x23ef;</button>
		<button onclick="nxt();">&#x25b6;</button>
	</div>
	<div>
		<h2>Replay anschauen</h2>
		<label for="file-to-load">Replay-Datei (JSON) hier ausw&auml;hlen:</label>
		<input type="file" id="file-to-load"/>
		<br/>
		<label for="load-file-button">Dann hier zum Laden clicken:</label>
		<button onclick="loadFile();" id="load-file-button">Datei laden</button>
	</div>
	<div>
		<h2 id="card">Karte auswählen</h2>
	</div>
	<div>
		<h2>Mit Live-Server verbinden</h2>
		<label for="server-to-connect">Server-Adresse</label>
		<input type="text" id="server-to-connect" value="revelation-server-2.westeurope.cloudapp.azure.com:8000"/>
		<label for="teamNr">Teamnummer eingeben</label>
		<input type="text" id="teamNr"/>
		<input type="text" value="submit" id="roomNr"/>
		<button onclick="httpRequest();">Neuen Raum starten</button>
		<input type="text" value="submit" id="existingRoomNr"/>
		<button onclick="connectToServer();">Raum beitreten</button>
		<span>Status:</span><span id="connection-status">Nicht verbunden</span>
	</div>
</body>
<script>

	var steps = [];
	var inverts = [];
	var playing = false;
	var initialized = false;
	var playLock = undefined;
	var socket = undefined;
	var currentStep = 0;
	var draggableCharacters;
	var selectedId;
	var charId;
	var stepCountDom = document.getElementById('step-count');
	var connectionStatusDom = document.getElementById('connection-status');
	var message;
	var boardfields = document.querySelectorAll('.board-field');
	var flag = false;
	const removeEvents = () => {
		boardfields.forEach(item => item.removeEventListener('mouseover', item.fn, false));
		boardfields.forEach(item => item.removeEventListener('click', startPos, false));
		boardfields.forEach(item => item.removeEventListener('mouseout', removeGrey_, false));
	}
	function removeGrey() {
		boardfields.forEach(function (item) {
			if(item.hasAttribute("style")) {
				item.setAttribute("style", "background-color:white;");
				if(item.hasChildNodes()) {
					item.firstElementChild.removeAttribute('style');
				}
			}
		});
	}
	function removeGrey_() {
		boardfields.forEach(function (item) {
			var color = item.getAttribute("style");
			if(item.hasAttribute("style") && !color.includes('red')) {
				item.setAttribute("style", "background-color:white;");
				if(item.hasChildNodes()) {
					item.firstElementChild.removeAttribute('style');
				}
			}
		});
	}
	function startChar() {
		if(this.id) {
			charId = this.id;
			this.style.backgroundColor = "red";
			this.parentElement.style.backgroundColor = "red";
			console.log(this.id);
			sockSendCharacter(this.id);
		}
	}
	function startPos() {
		selectedId = this.getAttribute('array');
		console.log(selectedId);
		if(selectedId === document.getElementById(charId).parentElement.getAttribute('array')) {
			socket.send(0);
		} else {
			sockSendPos(selectedId);
		}
	}
	function readMoves() {
		var moves = possibilities.forEach(item => item.split(' ').at(0));
		console.log(moves);
	}
	function showPos(fields, possibilities) {
		let i;
		const moves = [];
		for(i = 0; i < possibilities.length; i++) {
			moves.push(possibilities.at(i).split(' ').at(0).replace('\\"', ''))
		}
		moves.forEach(item =>
			item.split('').forEach(c => function () {
				switch (c) {
					case '>':
						var value = document.getElementById(charId).getAttribute('array');
				}
			}))


		for(i = 0; i < possibilities.length; i++) {
			for(j = 0; j < fields.length; j++) {
				cmp = fields.item(j).getAttribute('array');
				if(possibilities.at(i).includes(cmp)) {
					fields.item(j).setAttribute("style", "background-color:grey")
					if(fields.item(j).firstChild) {
						fields.item(j).firstChild.setAttribute("style", "background-color:grey");
					}
				}
			}
		}
	}
	const nxt = () => {
		const step = steps.shift();
		if(!step) return false;
		currentStep++; document.getElementById('current-step').textContent = currentStep;
		bwstep = apply(step, false);
		inverts.unshift( bwstep );
		return true;
	}
	const pre = () => {
		const inver = inverts.shift();
		if(!inver) return false;
		currentStep--; document.getElementById('current-step').textContent = currentStep;
		step = apply(inver, true);
		steps.unshift( step );
		return true;
	}
	const playLoop = (playBtn) => { const ret = nxt(); if(!ret){ pause(playBtn); } }
	const play = (playBtn) => {
		if(nxt()){
			playing = true;
			playBtn.textContent = '\u23f8';
			playLock = setInterval(playLoop, 1200, playBtn);
		}
	}
	const pause = (playBtn) => {
		playing = false;
		playBtn.textContent = '\u23ef';
		clearInterval(playLock);
		playLock = undefined;
	}
	const playPause = (playBtn) => {
		if(!playing) play(playBtn);
		else pause(playBtn);
	}
	const reloadNbSteps = () => {
		document.getElementById('nb-steps').textContent = '/' + (steps.length + currentStep);
	}
	const reloadCurrentStep = () => { document.getElementById('current-step').textContent = currentStep; }
	const restart = (stepsNState) => {
		state = stepsNState.state;
		if(typeof stepsNState.steps !== 'undefined') {
			steps = stepsNState.steps;
		} else {
			steps = []
		}
		inverts = [];
		currentStep = 0;
		reloadNbSteps(); reloadCurrentStep();
	}
	const loadFile = () => {
		const fileInput = document.getElementById('file-to-load');
		let file = fileInput.files[0];
		console.log(file);
		let reader = new FileReader();
		reader.onload = () => {
			var stepsNState = readGame(reader.result);
			console.log(stepsNState);
			restart(stepsNState);
		}
		reader.onerror = () => { console.warn('Could not load file because...\n' + reader.error); }
		reader.readAsText(file);
	}
	function loadCard(data){
		var message = JSON.stringify(data).split('",');
		var html = document.getElementById('card');
		html.innerHTML = '';
		var node = document.createElement('div');
		node.classList.add('grid');
		html.appendChild(node);
		node.innerHTML = '';
		for(var i = 0; i < message.length - 1; i++) {
			let card = message.at(i);
			if(card.includes('Hard')) {
				var link = document.createElement('img');
				link.src = "./image/hardAtk.jpg"
				link.onclick =  (function(t){return function(){sockSendCard(t);};})(i)
				node.appendChild(link);
			}
			else if(card.includes('Soft')) {
				var link = document.createElement('img');
				link.src = "./image/softAtk.jpg"
				link.onclick =  (function(t){return function(){sockSendCard(t);};})(i)
				node.appendChild(link);
			}
			else if(card.includes('Defense')) {
				var link = document.createElement('img');
				link.src = "./image/defense.jpg"
				link.onclick = (function(t){return function(){sockSendCard(t);};})(i)
				node.appendChild(link);
			}
			else if(card.includes('Skip')) {
				var link = document.createElement('button');
				link.innerHTML = 'Skip';
				link.onclick = (function(t){return function(){sockSendCard(t);};})(i)
				node.appendChild(link);
			}
			console.log(i);
		}
		console.log(message);
	}
	function httpRequest()  {
		const openRoom = new XMLHttpRequest();
		openRoom.onreadystatechange = () => {
			if(openRoom.readyState === XMLHttpRequest.DONE) {
				if(openRoom.status < 300) {
					console.log(openRoom.responseText);
					document.getElementById("roomNr").value = openRoom.responseText;
					document.getElementById('existingRoomNr').value = openRoom.responseText;
				} else {
					console.warn("ERROR");
				}
			}
		}
		openRoom.open("POST", "https://cors-anywhere.herokuapp.com/http://revelation-server-2.westeurope.cloudapp.azure.com:8000/room", true);
		openRoom.send();
		return openRoom.responseText;
	}
	const connectToServer = () => {
		const url = document.getElementById('server-to-connect').value;
		const teamNr = document.getElementById('teamNr').value;
		const roomNr = document.getElementById('existingRoomNr').value;

		connectionStatusDom.textContent = 'Verbindung starten...';
		if(window.WebSocket === undefined) {
			connectionStatusDom.textContent = 'WebSockets nicht unterstützt!';
			return;
		}

		socket = new WebSocket('ws://' + url + '/' + roomNr + '/' + teamNr);
		socket.onopen = (event) => {
			connectionStatusDom.textContent = 'Verbunden';
			initialized = false;
		};
		socket.onclose = (event) => { connectionStatusDom.textContent = 'Nicht verbunden'; };
		socket.onmessage = (event) => {
			try {
				JSON.parse(event.data)
				initialized = true;
			} catch (e) {
				initialized = false;
			}
			console.log(event.data);

			if(JSON.stringify(event.data).includes("state") && initialized) {
				stepsNState = readGame(event.data);
				restart(stepsNState);
				connectionStatusDom.textContent = 'Bereit';
				initialized = true;
			}

			if (JSON.stringify(event.data).includes("action") && !JSON.stringify(event.data).includes("state")) {
				removeGrey();
				let step = readStep(event.data, socket);
				steps.push(step);
				reloadNbSteps();
				if (steps.length == 1) nxt();
				removeEvents();
			} else if (JSON.stringify(event.data).includes("character") && !JSON.stringify(event.data).includes("state")) {
				message = event.data;
				draggableCharacters = document.querySelectorAll('.board-field div');
				draggableCharacters.forEach(item =>
						item.addEventListener('click', startChar)
				);
				removeEvents();

			} else if (JSON.stringify(event.data).includes("position") && !JSON.stringify(event.data).includes("state")) {
				possibilities = JSON.stringify(event.data).split('",');
				console.log(event.data);
				boardfields = document.querySelectorAll('.board-field');
				message = possibilities;
				draggableCharacters.forEach(item => item.removeEventListener('click', startChar, false));
				boardfields.forEach(item => item.addEventListener('click', startPos));
				boardfields.forEach(item => item.addEventListener('mouseover',
						item.fn = function () {
							showPos(boardfields, possibilities);
							this.style.backgroundColor = '#5A5A5A';
						}, false))
				boardfields.forEach(item => item.addEventListener('mouseout', removeGrey_, false))

			} else if (JSON.stringify(event.data).includes("card") && !JSON.stringify(event.data).includes("state")) {
				removeEvents();
				loadCard(event.data);
			}
		}
		socket.onerror = (err) => { console.error(err); }
	}

	function sockSendCharacter(id) {
		console.log(charId);
		socket.send(charId.split('-').at(1));
		socket.onerror = (err) => { console.error(err); }
	}

	function sockSendPos(id) {
		for(i = 0; i < message.length; i++) {
			if(message.at(i).includes(id)) {
				socket.send(i);
				break;
			}
		}
	}

	function sockSendCard(i) {
		console.log(i);
		socket.send(i);
	}

	const urlParams = new URLSearchParams(window.location.search);
	const liveurl = urlParams.get('liveurl');
	if(liveurl){
		document.getElementById('server-to-connect').value = liveurl;
		connectToServer();
	}

	var calculateMoves = function(content) {
		var moves = JSON.parse(content);
	}

</script>
</html>
